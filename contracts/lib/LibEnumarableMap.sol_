// SPDX-License-Identifier: MIT
pragma solidity 0.6.10;

library LibEnumarableMap {

    struct MapEntry {
        bytes32 key;
        bytes value;
    }

    struct Map {
        // index => id
        MapEntry[] entries;
        // id => order
        mapping(bytes32 => uint256) indexes;
    }

    function isEmpty(Map storage map) internal view returns (bool) {
        return map.entries.length == 0;
    }

    function has(Map storage map, uint256 key) internal view returns (bool) {
        return map.indexes[key] != 0;
    }

    function get(Map storage map, uint256 key) internal view returns (bytes memory value, bool isExist) {
        isExist = has(map, key);
        if (isExist) {
            value = map.entries[key].value;
        }
    }

    function set(Map storage map, bytes32 key, bytes value) internal returns (bool) {
        uint256 index = map.indexes[key];
        if (index == 0) {
            require(value.length != 0, "value is empty");
            // reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c6612871fb00299feb3edc09945a188b6ed3ee76/contracts/utils/EnumerableMap.sol#L60
            map.entries.push(MapEntry({
                key: key,
                value: value
            }));
            // index = actural index + 1
            map.indexes[key] = map.entries.length;
            return true;
        } else {
            // overwrite
            map.entries[index - 1].value = value;
            return false;
        }

    }

    function remove(Map storage map, bytes32 key) internal {
        require(has(map, key), "key not exist");
        // reference: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/c6612871fb00299feb3edc09945a188b6ed3ee76/contracts/utils/EnumerableMap.sol#L81
        uint256 index = map.indexes[key];
        uint256 toDeleteIndex = index - 1;
        uint256 lastIndex = map.entries.length - 1;
        MapEntry storage lastEntry = map.entries[lastIndex];
        map.entries[toDeleteIndex] = lastEntry;
        map.indexes[lastEntry.key] = toDeleteIndex + 1;
        map.entries.pop();
        delete map.indexes[key];
    }
}